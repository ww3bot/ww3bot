import os
import telebot
from telebot import types
import flask
import json
import threading
import time

# Ù…Ø­ÛŒØ·
TOKEN = os.environ.get("BOT_TOKEN")
OWNER_ID = int(os.environ.get("OWNER_ID"))
OWNER_ID_2 = int(os.environ.get("OWNER_ID_2"))
WEBHOOK_URL = os.environ.get("WEBHOOK_URL")

bot = telebot.TeleBot(TOKEN)
app = flask.Flask(__name__)

player_data = {}  # user_id -> country
pending_statements = {}
pending_assets = {}
player_assets = {}
bot_enabled = True

# Ø§Ø¨Ø²Ø§Ø±
def is_owner(message):
    return message.from_user.id in [OWNER_ID, OWNER_ID_2]

def main_menu(user_id):
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("\ud83d\udcc3 \u0627\u0631\u0633\u0627\u0644 \u0628\u06cc\u0627\u0646\u06cc\u0647", callback_data=f"statement:{user_id}"))
    markup.add(types.InlineKeyboardButton("\ud83d\udcbc \u062f\u0627\u0631\u0627\u06cc\u06cc", callback_data=f"assets:{user_id}"))
    return markup

# Ø³Øª Ú©Ø´ÙˆØ±
@bot.message_handler(commands=['setcountry'])
def set_country(message):
    if not is_owner(message): return
    if not message.reply_to_message:
        bot.reply_to(message, "Ø¨Ø§ÛŒØ¯ Ø±ÙˆÛŒ Ù¾ÛŒØ§Ù… Ù¾Ù„ÛŒØ± Ø±ÛŒÙ¾Ù„Ø§ÛŒ Ú©Ù†ÛŒ Ùˆ Ù†Ø§Ù… Ú©Ø´ÙˆØ± Ø±Ùˆ Ø¨Ù†ÙˆÛŒØ³ÛŒ Ù…Ø«Ù„ /setcountry Ø§ÛŒØ±Ø§Ù†")
        return
    try:
        user_id = message.reply_to_message.from_user.id
        country = message.text.split(None, 1)[1]
        player_data[user_id] = country
        bot.reply_to(message, f"âœ… Ú©Ø´ÙˆØ± {country} Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± {user_id} Ø«Ø¨Øª Ø´Ø¯")
    except:
        bot.reply_to(message, "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙØ±Ù…Ø§Ù†")

# Ø³Øª Ø¯Ø§Ø±Ø§ÛŒÛŒ
@bot.message_handler(commands=['setassets'])
def set_assets(message):
    if not is_owner(message): return
    if not message.reply_to_message:
        bot.reply_to(message, "Ø¨Ø§ÛŒØ¯ Ø±ÙˆÛŒ Ù¾ÛŒØ§Ù… Ø­Ø§ÙˆÛŒ Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø±ÛŒÙ¾Ù„Ø§ÛŒ Ú©Ù†ÛŒ Ùˆ Ù†Ø§Ù… Ú©Ø´ÙˆØ± Ø±Ùˆ Ø¨Ø²Ù†ÛŒ Ù…Ø«Ù„ /setassets Ø§ÛŒØ±Ø§Ù†")
        return
    try:
        user_id = None
        country = message.text.split(None, 1)[1]
        for uid, cname in player_data.items():
            if cname == country:
                user_id = uid
                break
        if not user_id:
            bot.reply_to(message, "â›” Ú©Ø´ÙˆØ± Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯")
            return
        pending_assets[user_id] = message.reply_to_message.text
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("âœ… ØªØ§ÛŒÛŒØ¯", callback_data=f"confirm_assets:{user_id}"))
        markup.add(types.InlineKeyboardButton("âŒ Ù„ØºÙˆ", callback_data=f"cancel_assets:{user_id}"))
        bot.send_message(message.chat.id, f"Ù…ØªÙ† Ø¯Ø§Ø±Ø§ÛŒÛŒ:\n{message.reply_to_message.text}\n\nÙ…ÙˆØ±Ø¯ ØªØ§ÛŒÛŒØ¯ Ù‡Ø³ØªØŸ", reply_markup=markup)
    except:
        bot.reply_to(message, "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙØ±Ù…Ø§Ù†")

# Ø±ÙˆØ´Ù† Ùˆ Ø®Ø§Ù…ÙˆØ´
@bot.message_handler(commands=['on'])
def turn_on(message):
    global bot_enabled
    if is_owner(message):
        bot_enabled = True
        bot.reply_to(message, "âœ… Ø±Ø¨Ø§Øª Ø±ÙˆØ´Ù† Ø´Ø¯")

@bot.message_handler(commands=['off'])
def turn_off(message):
    global bot_enabled
    if is_owner(message):
        bot_enabled = False
        bot.reply_to(message, "âš ï¸ Ø±Ø¨Ø§Øª Ø®Ø§Ù…ÙˆØ´ Ø´Ø¯")

# Ù…Ù†Ùˆ
@bot.message_handler(commands=['start', 'panel'])
def send_menu(message):
    if not bot_enabled:
        bot.reply_to(message, "â›” Ø±Ø¨Ø§Øª Ø®Ø§Ù…ÙˆØ´ Ø§Ø³Øª")
        return
    uid = message.from_user.id
    if uid in player_data or is_owner(message):
        bot.send_message(message.chat.id, "Ø¨Ù‡ Ù¾Ù†Ù„ Ú¯ÛŒÙ… Ù…ØªÙ†ÛŒ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯", reply_markup=main_menu(uid))

# Ø¨ÛŒØ§Ù†ÛŒÙ‡
@bot.callback_query_handler(func=lambda call: call.data.startswith("statement:"))
def handle_statement(call):
    target_id = int(call.data.split(":")[1])
    if call.from_user.id == target_id or call.from_user.id in [OWNER_ID, OWNER_ID_2]:
        msg = bot.send_message(call.message.chat.id, "Ù…ØªÙ† Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:")
        bot.register_next_step_handler(msg, lambda m: process_statement(m, target_id))

def process_statement(message, target_id):
    pending_statements[target_id] = message.text
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("âœ… ØªØ§ÛŒÛŒØ¯", callback_data=f"confirm_statement:{target_id}"))
    markup.add(types.InlineKeyboardButton("âŒ Ù„ØºÙˆ", callback_data=f"cancel_statement:{target_id}"))
    bot.send_message(message.chat.id, f"{player_data.get(target_id, 'Ú©Ø´ÙˆØ± Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡')}\n{message.text}\n\nÙ…ÙˆØ±Ø¯ ØªØ§ÛŒÛŒØ¯ Ø§Ø³ØªØŸ", reply_markup=markup)

@bot.callback_query_handler(func=lambda c: c.data.startswith("confirm_statement") or c.data.startswith("cancel_statement"))
def confirm_statement_handler(call):
    parts = call.data.split(":")
    target_id = int(parts[1])
    if call.data.startswith("confirm_statement"):
        text = f"ğŸ“¢ Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø§Ø² Ú©Ø´ÙˆØ± {player_data.get(target_id, 'Ù†Ø§Ù…Ø´Ø®Øµ')}:\n{pending_statements[target_id]}"
        bot.send_message(call.message.chat.id, "âœ… Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯")
        bot.send_message(f"@{player_data.get(target_id, 'Ù†Ø§Ù…Ø´Ø®Øµ')}", text)
    else:
        bot.send_message(call.message.chat.id, "âŒ Ø¨ÛŒØ§Ù†ÛŒÙ‡ Ù„ØºÙˆ Ø´Ø¯")
    pending_statements.pop(target_id, None)

# ØªØ§ÛŒÛŒØ¯ Ø¯Ø§Ø±Ø§ÛŒÛŒ
@bot.callback_query_handler(func=lambda c: c.data.startswith("confirm_assets") or c.data.startswith("cancel_assets"))
def confirm_assets_handler(call):
    parts = call.data.split(":")
    user_id = int(parts[1])
    if call.data.startswith("confirm_assets"):
        player_assets[user_id] = pending_assets.get(user_id, "Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡")
        bot.send_message(call.message.chat.id, "âœ… Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø«Ø¨Øª Ø´Ø¯")
    else:
        bot.send_message(call.message.chat.id, "âŒ Ø¯Ø§Ø±Ø§ÛŒÛŒ Ù„ØºÙˆ Ø´Ø¯")
    pending_assets.pop(user_id, None)

# Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø±Ø§ÛŒÛŒ
@bot.callback_query_handler(func=lambda c: c.data.startswith("assets:"))
def handle_assets(call):
    target_id = int(call.data.split(":")[1])
    if call.from_user.id == target_id or call.from_user.id in [OWNER_ID, OWNER_ID_2]:
        text = player_assets.get(target_id, "â›” Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡")
        bot.send_message(call.message.chat.id, f"ğŸ“¦ Ø¯Ø§Ø±Ø§ÛŒÛŒ:\n{text}")
    else:
        bot.send_message(call.message.chat.id, "â›” Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯")

# Ø§Ø±ØªÙ‚Ø§Ø¡ Ø¨Ø§Ø²Ø¯Ù‡ÛŒ Ú©Ù„ÛŒ ØªÙˆØ³Ø· Ø§Ø¯Ù…ÛŒÙ†
@bot.message_handler(commands=['up'])
def handle_up_all(message):
    if not is_owner(message):
        bot.send_message(message.chat.id, "â›” ÙÙ‚Ø· Ø§Ø¯Ù…ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨Ø§Ø²Ø¯Ù‡ÛŒ Ù‡Ù…Ù‡ Ú©Ø´ÙˆØ±Ù‡Ø§ Ø±Ø§ Ø¨Ù‡â€ŒØ±ÙˆØ² Ú©Ù†Ø¯")
        return

    updated_count = 0
    for user_id, original_text in player_assets.items():
        updated_lines = []
        for line in original_text.splitlines():
            if '[' in line and ']' in line and ':' in line:
                try:
                    label, value_part = line.split(':', 1)
                    base = int(value_part.strip())
                    name, bracket = label.split('[', 1)
                    yield_value = int(bracket.split(']')[0])
                    total = base + yield_value
                    new_line = f"{name.strip()}[{yield_value}]: {total}"
                    updated_lines.append(new_line)
                except:
                    updated_lines.append(line)
            else:
                updated_lines.append(line)
        updated_text = '\n'.join(updated_lines)
        player_assets[user_id] = updated_text
        group = f"@{player_data.get(user_id, 'Ù†Ø§Ù…Ø´Ø®Øµ')}"
        bot.send_message(group, f"ğŸ“ˆ Ø¯Ø§Ø±Ø§ÛŒÛŒ Ø¨Ø§ Ø¨Ø§Ø²Ø¯Ù‡ÛŒ Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯:\n{updated_text}")
        updated_count += 1
    bot.send_message(message.chat.id, f"âœ… Ø¨Ø§Ø²Ø¯Ù‡ÛŒ {updated_count} Ú©Ø´ÙˆØ± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯")

# Ø¨Ú©Ø§Ù¾â€ŒÚ¯ÛŒØ±ÛŒ
BACKUP_FILE = "backup.json"
def backup_data():
    while True:
        try:
            with open(BACKUP_FILE, 'w', encoding='utf-8') as f:
                json.dump({"countries": player_data, "assets": player_assets}, f, ensure_ascii=False)
        except Exception as e:
            print("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ú©Ø§Ù¾ Ú¯ÛŒØ±ÛŒ:", e)
        time.sleep(600)  # Ù‡Ø± 10 Ø¯Ù‚ÛŒÙ‚Ù‡

threading.Thread(target=backup_data, daemon=True).start()

# Webhook
@app.route('/', methods=['POST'])
def webhook():
    if flask.request.headers.get('content-type') == 'application/json':
        json_string = flask.request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_string)
        bot.process_new_updates([update])
        return ''
    else:
        flask.abort(403)

bot.remove_webhook()
bot.set_webhook(url=WEBHOOK_URL)

print("Ø±Ø¨Ø§Øª Ø¨Ø§ webhook Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯...")

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 5000)))
